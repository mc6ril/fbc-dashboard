---
Generated: 2025-01-27 18:00:00
Ticket Number: 3
---

## Jira Ticket

**Title:** Implement React Query (TanStack Query) across the project with DevTools and best practices

**Type:** Feature

**Priority:** High

**Story Points:** 5

**Labels:** infrastructure, data-fetching, react-query, performance, caching

**Git Branch:** `feat/fbc-3-implement-react-query`

**Branch Creation:**

```bash
git checkout -b feat/fbc-3-implement-react-query
```

---

**Description:**

React Query (TanStack Query) is already partially integrated in the project with the `ReactQueryProvider` and authentication hooks (`useAuth.ts`), but the implementation needs to be completed and standardized across the entire project. This ticket ensures React Query is fully implemented with:

1. React Query DevTools for development debugging
2. Centralized query key factories for consistent cache management
3. Standardized hook patterns and best practices
4. Proper configuration for all query types (queries, mutations, infinite queries)
5. Documentation and examples for future development
6. Performance optimizations (selectors, staleTime, cacheTime)
7. Error handling patterns

This implementation will provide a solid foundation for all data fetching operations in the FBC Dashboard, ensuring consistent caching, error handling, and loading states across all features while maintaining Clean Architecture principles.

**Current State:**

-   ✅ `@tanstack/react-query` package installed (v5.90.9)
-   ✅ `ReactQueryProvider` created in `presentation/providers/ReactQueryProvider.tsx`
-   ✅ Provider integrated in `app/layout.tsx`
-   ✅ Authentication hooks (`useAuth.ts`) using React Query
-   ❌ React Query DevTools not configured
-   ❌ No centralized query key factories
-   ❌ No standardized patterns documentation
-   ❌ Query configuration could be optimized

**User Story:**

As a developer
I want React Query fully implemented with DevTools, query key factories, and best practices
So that all data fetching operations are consistent, performant, and easy to debug across the entire application

---

**Acceptance Criteria:**

-   [ ] AC1: React Query DevTools is installed and configured for development environment only
-   [ ] AC2: DevTools are conditionally rendered based on environment (development only, not in production)
-   [ ] AC3: Centralized query key factory is created in `presentation/hooks/queryKeys.ts` for consistent cache key management
-   [ ] AC4: Query key factory follows hierarchical structure: `["resource", "id", "filters"]` pattern
-   [ ] AC5: ReactQueryProvider configuration is optimized with appropriate defaults for queries and mutations
-   [ ] AC6: Documentation file is created in `docs/react-query-patterns.md` with examples and best practices
-   [ ] AC7: All existing React Query hooks follow the standardized patterns (query keys, error handling, loading states)
-   [ ] AC8: Query configuration includes proper `staleTime`, `gcTime`, and `retry` settings based on data type
-   [ ] AC9: Mutation hooks properly invalidate related queries on success
-   [ ] AC10: Error handling is consistent across all React Query hooks with proper error types
-   [ ] AC11: Loading states are properly managed with `isLoading`, `isFetching`, and `isPending` where appropriate
-   [ ] AC12: React Query selectors are used for data transformation when needed (performance optimization)
-   [ ] AC13: Conditional queries use `enabled` option properly (e.g., queries that depend on authentication)
-   [ ] AC14: All React Query hooks are properly typed with TypeScript (no `any` types)
-   [ ] AC15: README.md is updated with React Query setup and usage information

---

**Technical Considerations:**

-   **Architecture Layers Impacted:**

    -   **Domain** (`core/domain/`):

        -   No changes (React Query is presentation layer concern)

    -   **Ports** (`core/ports/`):

        -   No changes (ports define contracts, not implementation)

    -   **Usecases** (`core/usecases/`):

        -   No changes (usecases remain pure functions)

    -   **Infrastructure** (`infrastructure/`):

        -   No changes (infrastructure implements ports, React Query is in presentation)

    -   **Presentation** (`presentation/`):
        -   **Providers** (`presentation/providers/`):
            -   Update `ReactQueryProvider.tsx` to include DevTools
            -   Optimize QueryClient configuration
        -   **Hooks** (`presentation/hooks/`):
            -   Create `queryKeys.ts` for centralized query key management
            -   Update existing hooks to use query key factory
            -   Ensure all hooks follow standardized patterns
        -   **Components** (`presentation/components/`):
            -   No direct changes, but components will benefit from optimized hooks

-   **Dependencies:**

    -   `@tanstack/react-query` (already installed: ^5.90.9)
    -   `@tanstack/react-query-devtools` (to be installed as dev dependency)

-   **Data Flow:**

    ```
    UI Component
        ↓ calls
    React Query Hook (useQuery, useMutation)
        ↓ calls
    Usecase (from core/usecases/)
        ↓ calls
    Repository (from infrastructure/)
        ↓ calls
    Supabase/External API
    ```

    React Query manages:

    -   Caching and cache invalidation
    -   Loading and error states
    -   Background refetching
    -   Request deduplication
    -   Optimistic updates

-   **React Query DevTools:**

    -   Install `@tanstack/react-query-devtools` as dev dependency
    -   Conditionally render DevTools only in development environment
    -   DevTools should be integrated in `ReactQueryProvider` component
    -   Use `process.env.NODE_ENV === "development"` to check environment

-   **Query Key Factory Pattern:**

    -   Create centralized factory in `presentation/hooks/queryKeys.ts`
    -   Use hierarchical structure for cache keys:
        ```typescript
        export const queryKeys = {
            auth: {
                session: () => ["auth", "session"] as const,
                user: () => ["auth", "user"] as const,
            },
            products: {
                all: () => ["products"] as const,
                detail: (id: string) => ["products", id] as const,
                list: (filters?: ProductFilters) => ["products", "list", filters] as const,
            },
        };
        ```
    -   Benefits: Type safety, consistent keys, easy invalidation

-   **Query Configuration:**

    -   **Queries:**

        -   `staleTime`: 5 minutes (default) - data considered fresh
        -   `gcTime`: 10 minutes (default) - unused data kept in cache
        -   `retry`: 1 (default) - retry failed requests once
        -   `refetchOnWindowFocus`: true (default) - refetch on window focus
        -   Customize per query type (e.g., auth queries may need different settings)

    -   **Mutations:**
        -   `retry`: 1 (default) - retry failed mutations once
        -   Always invalidate related queries on success
        -   Use optimistic updates where appropriate

-   **Error Handling:**

    -   All hooks should properly type errors from usecases
    -   Use error boundaries for global error handling
    -   Provide user-friendly error messages
    -   Log errors for debugging

-   **Performance Optimizations:**

    -   Use `select` option to transform data only when needed
    -   Use `enabled` option for conditional queries
    -   Use `keepPreviousData` for pagination
    -   Use `staleTime` to prevent unnecessary refetches
    -   Use Zustand selectors to prevent unnecessary re-renders

-   **Testing:**

    -   Mock React Query in component tests
    -   Test query key factories
    -   Test query invalidation logic
    -   Test error handling in hooks

---

**Definition of Done:**

-   [ ] `@tanstack/react-query-devtools` installed as dev dependency
-   [ ] React Query DevTools integrated in `ReactQueryProvider` (development only)
-   [ ] Query key factory created in `presentation/hooks/queryKeys.ts`
-   [ ] All existing hooks updated to use query key factory
-   [ ] `ReactQueryProvider` configuration optimized with appropriate defaults
-   [ ] Documentation created in `docs/react-query-patterns.md` with examples
-   [ ] All React Query hooks follow standardized patterns
-   [ ] Error handling is consistent across all hooks
-   [ ] Loading states are properly managed
-   [ ] React Query selectors used where appropriate for performance
-   [ ] Conditional queries use `enabled` option properly
-   [ ] All hooks are properly typed with TypeScript (no `any` types)
-   [ ] README.md updated with React Query information
-   [ ] DevTools tested in development environment
-   [ ] DevTools verified not rendering in production build
-   [ ] Code reviewed and approved
-   [ ] No performance regressions

---

**Related Components:**

-   **Files to create:**

    -   `presentation/hooks/queryKeys.ts` - Centralized query key factory
    -   `docs/react-query-patterns.md` - Documentation and best practices

-   **Files to modify:**

    -   `presentation/providers/ReactQueryProvider.tsx` - Add DevTools, optimize configuration
    -   `presentation/hooks/useAuth.ts` - Update to use query key factory
    -   `package.json` - Add `@tanstack/react-query-devtools` dev dependency
    -   `README.md` - Add React Query setup and usage information

-   **Implementation notes:**

    -   DevTools should only render in development: `process.env.NODE_ENV === "development"`
    -   Query key factory should be type-safe and hierarchical
    -   All query keys should be defined in the factory, not inline
    -   Query configuration should be optimized per data type (auth, products, etc.)
    -   Mutations should always invalidate related queries
    -   Use `select` option for data transformation to prevent unnecessary re-renders
    -   Use `enabled` option for conditional queries (e.g., queries that require authentication)
    -   Follow Clean Architecture: hooks call usecases, not repositories directly
    -   All hooks should be properly typed with TypeScript
    -   Error handling should be consistent and user-friendly

-   **Query Key Factory Example:**

    ```typescript
    /**
     * Centralized query key factory for React Query.
     *
     * Provides type-safe, hierarchical query keys for consistent cache management.
     * All query keys should be defined here to ensure consistency and easy invalidation.
     */
    export const queryKeys = {
        auth: {
            session: () => ["auth", "session"] as const,
            user: () => ["auth", "user"] as const,
        },
        // Add more resource keys as needed:
        // products: {
        //   all: () => ["products"] as const,
        //   detail: (id: string) => ["products", id] as const,
        //   list: (filters?: ProductFilters) => ["products", "list", filters] as const,
        // },
    };
    ```

-   **DevTools Integration Example:**

    ```typescript
    import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

    const ReactQueryProvider = ({ children }: Props) => {
        const [queryClient] = useState(
            () =>
                new QueryClient({
                    /* ... */
                })
        );

        return (
            <QueryClientProvider client={queryClient}>
                {children}
                {process.env.NODE_ENV === "development" && <ReactQueryDevtools initialIsOpen={false} />}
            </QueryClientProvider>
        );
    };
    ```

-   **Documentation Structure:**

    -   Overview of React Query in the project
    -   Query key factory usage
    -   Creating new hooks (queries and mutations)
    -   Best practices and patterns
    -   Performance optimizations
    -   Error handling
    -   Testing React Query hooks
    -   Common pitfalls and solutions

---

**Dependencies:**

-   This ticket builds on the existing React Query setup from authentication implementation
-   Future data fetching features will use the patterns established in this ticket
-   All new hooks should follow the patterns documented in this ticket

---

**Performance Considerations:**

-   React Query provides automatic caching, reducing unnecessary network requests
-   Query key factory ensures consistent cache invalidation
-   Selectors prevent unnecessary re-renders by selecting only needed data
-   Proper `staleTime` configuration prevents excessive refetching
-   DevTools help identify performance issues during development

---

**Security Considerations:**

-   React Query DevTools should never be included in production builds
-   Query keys should not expose sensitive information
-   Error messages should not leak sensitive data
-   All data fetching goes through Clean Architecture layers (security enforced at infrastructure level)
