---
Generated: 2025-01-27 21:00:00
Ticket Number: 30
---

# Implement product reference tables for type-model-coloris validation

-   Type: Feature
-   Priority: High
-   Story Points: 8
-   Labels: database, schema, products, validation, filtering, core, infrastructure, presentation
-   Git Branch: feat/fbc-30-product-reference-tables

## Description

Implement reference tables for product models and coloris to enforce valid combinations and enable fast filtering. This prevents naming errors and ensures data integrity by validating that only valid type → model → coloris combinations can be created.

**Current state:**

-   Products table has free-text `name` and `coloris` fields
-   No validation of valid combinations (e.g., "Sac banane" type with "Charlie" name is invalid)
-   No cascading filters in forms (users can enter any name/coloris regardless of type)
-   Risk of data inconsistencies and naming errors

**Business requirement:**

-   Type determines available models (e.g., POCHETTE_VOLANTS → "Charlie", SAC_BANANE → "assumée", "espiègle")
-   Type + Model determines available coloris (e.g., POCHETTE_VOLANTS + "Charlie" → "Rose Marsala", "Rose pâle à motifs")
-   Database-level validation to prevent invalid combinations
-   Fast filtering for cascading dropdowns in forms
-   Easy maintenance of valid combinations via reference tables

**Example valid combinations:**

-   Type: POCHETTE_VOLANTS → Model: "Charlie" → Coloris: "Rose Marsala", "Rose pâle à motifs"
-   Type: SAC_BANANE → Model: "assumée", "espiègle" → Coloris: "Prune", "Rouge" (for assumée)

## User Story

**As a** user  
**I want** to select product type, model, and coloris from validated dropdowns  
**So that** I can only create products with valid combinations and avoid naming errors

## Acceptance Criteria

### Database Schema (Infrastructure)

-   [ ] Create `product_models` table in migration
    -   Columns: `id` (UUID PK), `type` (TEXT with CHECK constraint matching ProductType enum), `name` (TEXT NOT NULL)
    -   Unique constraint on `(type, name)` to prevent duplicates
    -   Index on `type` for fast filtering
    -   Comments on table and columns
-   [ ] Create `product_coloris` table in migration
    -   Columns: `id` (UUID PK), `model_id` (UUID FK to product_models, ON DELETE CASCADE), `coloris` (TEXT NOT NULL)
    -   Unique constraint on `(model_id, coloris)` to prevent duplicates
    -   Index on `model_id` for fast filtering
    -   Comments on table and columns
-   [ ] Modify `products` table in migration
    -   Add `model_id` column (UUID FK to product_models, nullable initially for migration)
    -   Add `coloris_id` column (UUID FK to product_coloris, nullable initially for migration)
    -   Keep existing `name`, `type`, `coloris` columns temporarily for backward compatibility
    -   Add migration script to populate reference tables from existing products
    -   Add migration script to update `model_id` and `coloris_id` from existing data
    -   After migration, make `model_id` and `coloris_id` NOT NULL and remove old columns (or mark as deprecated)
-   [ ] Create migration script `002_create_product_reference_tables.sql`
    -   Follows naming convention and includes comments
    -   Includes data migration from existing products
    -   Includes verification script
-   [ ] Create verification script `002_verify_product_reference_tables.sql`
    -   Verifies tables exist
    -   Verifies constraints and foreign keys
    -   Verifies indices
    -   Verifies data migration success

### Domain Layer (Core)

-   [ ] Create `ProductModel` type in `src/core/domain/product.ts`
    -   Fields: `id` (ProductModelId), `type` (ProductType), `name` (string)
    -   Branded type `ProductModelId`
    -   JSDoc documentation
-   [ ] Create `ProductColoris` type in `src/core/domain/product.ts`
    -   Fields: `id` (ProductColorisId), `modelId` (ProductModelId), `coloris` (string)
    -   Branded type `ProductColorisId`
    -   JSDoc documentation
-   [ ] Update `Product` type in `src/core/domain/product.ts`
    -   Add `modelId` (ProductModelId) field
    -   Add `colorisId` (ProductColorisId) field
    -   Keep `name`, `type`, `coloris` as optional/deprecated for backward compatibility during migration
    -   Update JSDoc to reflect new structure
-   [ ] Add validation functions in `src/core/domain/validation.ts`
    -   `isValidProductModel(productModel: ProductModel): boolean`
    -   `isValidProductColoris(productColoris: ProductColoris): boolean`
    -   `isValidProductModelForType(model: ProductModel, type: ProductType): boolean`
    -   `isValidProductColorisForModel(coloris: ProductColoris, modelId: ProductModelId): boolean`

### Ports Layer (Core)

-   [ ] Add methods to `ProductRepository` interface in `src/core/ports/productRepository.ts`
    -   `listModelsByType(type: ProductType): Promise<ProductModel[]>`
    -   `listColorisByModel(modelId: ProductModelId): Promise<ProductColoris[]>`
    -   `getModelById(id: ProductModelId): Promise<ProductModel | null>`
    -   `getColorisById(id: ProductColorisId): Promise<ProductColoris | null>`
    -   JSDoc documentation for each method

### Infrastructure Layer

-   [ ] Implement repository methods in `productRepositorySupabase.ts`
    -   `listModelsByType`: Query `product_models` table filtered by type
    -   `listColorisByModel`: Query `product_coloris` table filtered by model_id
    -   `getModelById`: Query single model by ID
    -   `getColorisById`: Query single coloris by ID
    -   Map Supabase rows to domain types
    -   Handle errors appropriately
-   [ ] Update `create` method in `productRepositorySupabase.ts`
    -   Accept `modelId` and `colorisId` instead of `name` and `coloris`
    -   Validate that model and coloris exist and match
    -   Update Supabase insert to use `model_id` and `coloris_id`
-   [ ] Update `update` method in `productRepositorySupabase.ts`
    -   Accept `modelId` and `colorisId` instead of `name` and `coloris`
    -   Validate that model and coloris exist and match
    -   Update Supabase update to use `model_id` and `coloris_id`
-   [ ] Update `list` method in `productRepositorySupabase.ts`
    -   Join with `product_models` and `product_coloris` tables
    -   Map to domain Product type with `modelId` and `colorisId`
    -   Include `name`, `type`, `coloris` from joined tables for backward compatibility

### Usecases Layer (Core)

-   [ ] Add usecases in `src/core/usecases/product.ts`
    -   `listProductModelsByType(repo: ProductRepository, type: ProductType): Promise<ProductModel[]>`
    -   `listProductColorisByModel(repo: ProductRepository, modelId: ProductModelId): Promise<ProductColoris[]>`
    -   `getProductModel(repo: ProductRepository, id: ProductModelId): Promise<ProductModel | null>`
    -   `getProductColoris(repo: ProductRepository, id: ProductColorisId): Promise<ProductColoris | null>`
    -   Update `createProduct` usecase to validate model and coloris combination
    -   Update `updateProduct` usecase to validate model and coloris combination
    -   JSDoc documentation for each usecase

### Presentation Layer

-   [ ] Create React Query hooks in `src/presentation/hooks/useProducts.ts`
    -   `useProductModelsByType(type: ProductType | null)`: Fetches models for a type
    -   `useProductColorisByModel(modelId: ProductModelId | null)`: Fetches coloris for a model
    -   Use `enabled` option to conditionally fetch based on selections
    -   Proper query keys for caching
-   [ ] Update `ProductForm` component in `src/presentation/components/catalog/ProductForm/ProductForm.tsx`
    -   Replace `name` input with `Select` dropdown for models (filtered by type)
    -   Replace `coloris` input with `Select` dropdown for coloris (filtered by model)
    -   Implement cascading filters: type change clears model and coloris, model change clears coloris
    -   Update form state to use `modelId` and `colorisId` instead of `name` and `coloris`
    -   Update validation to ensure model and coloris are selected
    -   Update form submission to send `modelId` and `colorisId`
-   [ ] Update `ProductsTable` component if needed
    -   Display model name and coloris from joined data
    -   Ensure proper rendering of product information

### Tests

-   [ ] Add unit tests for domain validation functions in `__tests__/core/domain/validation.test.ts`
-   [ ] Add unit tests for usecases in `__tests__/core/usecases/product.test.ts`
    -   Test `listProductModelsByType`
    -   Test `listProductColorisByModel`
    -   Test validation in `createProduct` and `updateProduct`
-   [ ] Update existing product tests to use new structure
-   [ ] Add integration tests for repository methods (if applicable)

## Technical Considerations

### Architecture Layers

**Domain Layer (`core/domain/`):**

-   New types: `ProductModel`, `ProductColoris`
-   Branded types: `ProductModelId`, `ProductColorisId`
-   Updated `Product` type with `modelId` and `colorisId`
-   Validation functions for models and coloris

**Ports Layer (`core/ports/`):**

-   New repository methods for querying models and coloris
-   Methods follow existing repository pattern

**Usecases Layer (`core/usecases/`):**

-   New usecases for listing models and coloris
-   Updated create/update usecases with validation

**Infrastructure Layer (`infrastructure/supabase/`):**

-   New tables: `product_models`, `product_coloris`
-   Modified `products` table with foreign keys
-   Repository implementations with joins and filtering
-   Migration scripts with data migration

**Presentation Layer (`presentation/`):**

-   New React Query hooks for models and coloris
-   Updated `ProductForm` with cascading selects
-   Conditional fetching based on user selections

### Data Flow

```
User selects Type
    ↓
React Query Hook (useProductModelsByType)
    ↓
Usecase (listProductModelsByType)
    ↓
Repository (listModelsByType)
    ↓
Supabase (product_models table filtered by type)
    ↓
User selects Model
    ↓
React Query Hook (useProductColorisByModel)
    ↓
Usecase (listProductColorisByModel)
    ↓
Repository (listColorisByModel)
    ↓
Supabase (product_coloris table filtered by model_id)
    ↓
User selects Coloris
    ↓
Form submission with modelId + colorisId
    ↓
Usecase (createProduct/updateProduct with validation)
    ↓
Repository (create/update with model_id + coloris_id)
    ↓
Supabase (products table)
```

### Database Schema Changes

**New Tables:**

-   `product_models`: Reference table for valid model names per type
-   `product_coloris`: Reference table for valid coloris per model

**Modified Table:**

-   `products`: Add `model_id` and `coloris_id` foreign keys

**Migration Strategy:**

1.  Create reference tables
2.  Populate reference tables from existing products (extract unique combinations)
3.  Add `model_id` and `coloris_id` columns to products (nullable)
4.  Update existing products with correct `model_id` and `coloris_id`
5.  Make columns NOT NULL
6.  Remove old `name` and `coloris` columns (or mark as deprecated for backward compatibility)

### Dependencies

-   Depends on existing product domain types and repository
-   Requires database migration before code changes
-   May require data cleanup if existing products have invalid combinations

### Related Components

**Files to Create:**

-   `src/infrastructure/supabase/migrations/002_create_product_reference_tables.sql`
-   `src/infrastructure/supabase/migrations/002_verify_product_reference_tables.sql`

**Files to Modify:**

-   `src/core/domain/product.ts` (new types, update Product type)
-   `src/core/domain/validation.ts` (new validation functions)
-   `src/core/ports/productRepository.ts` (new repository methods)
-   `src/core/usecases/product.ts` (new usecases, update existing)
-   `src/infrastructure/supabase/productRepositorySupabase.ts` (implement new methods, update existing)
-   `src/presentation/hooks/useProducts.ts` (new hooks)
-   `src/presentation/components/catalog/ProductForm/ProductForm.tsx` (cascading selects)
-   `__tests__/core/domain/validation.test.ts` (new tests)
-   `__tests__/core/usecases/product.test.ts` (new tests, update existing)

## Definition of Done

-   [ ] Database migration created and tested
-   [ ] Reference tables created with proper constraints and indices
-   [ ] Data migration completed successfully
-   [ ] Domain types created and documented
-   [ ] Repository methods implemented and tested
-   [ ] Usecases implemented and tested
-   [ ] React Query hooks created
-   [ ] ProductForm updated with cascading selects
-   [ ] Validation prevents invalid combinations
-   [ ] All tests pass
-   [ ] Code follows Clean Architecture principles
-   [ ] SCSS variables used (no hardcoded values)
-   [ ] Accessibility requirements met (ARIA labels, keyboard navigation)
-   [ ] Code review completed
-   [ ] Documentation updated (Mermaid diagram created)

## Notes

-   Consider backward compatibility during migration period
-   May need to handle existing products with invalid combinations
-   Reference tables should be populated with initial data (seed data)
-   Consider admin interface for managing reference tables in future tickets
