---
Generated: 2025-01-27 20:00:00
Ticket Number: 30
---

# FBC-30: Ensure atomic stock updates everywhere

## Type

Bug / Technical Debt

## Priority

High

## Story Points

5

## Labels

`atomicity`, `race-condition`, `data-consistency`, `database`, `stock-management`

## Git Branch

`feat/fbc-30-atomic-stock-updates-everywhere`

## Description

Fix race conditions and non-atomic stock update operations to ensure data consistency. Currently, two issues allow stock updates to be non-atomic or create race conditions:

1. **`updateProduct` allows direct stock updates**: The `updateProduct` usecase accepts `stock` in updates, which bypasses atomic operations and can overwrite concurrent activity changes, causing data inconsistency.

2. **Race condition in `updateActivity`**: Between reading current stock (`getById`) and applying the delta (`updateStockAtomically`), concurrent operations can modify stock, leading to incorrect stock values.

## User Story

As a developer, I want all stock updates to be atomic and race-condition-free, so that product stock levels remain consistent even under concurrent activity operations.

## Acceptance Criteria

1. **Direct stock updates are prevented in `updateProduct`**:

    - `updateProduct` rejects updates that include `stock` field
    - Error message clearly indicates that stock must be updated via activities only
    - Tests verify that attempting to update stock via `updateProduct` throws an appropriate error

2. **Race condition fixed in `updateActivity`**:

    - A PostgreSQL RPC function `recalculate_and_update_stock(product_id)` is created
    - The function atomically calculates stock from all activities and updates the product stock in a single operation
    - `updateActivity` uses this RPC function instead of the read-modify-write pattern
    - Tests verify that concurrent activity updates do not cause race conditions

3. **All stock operations use atomic methods**:
    - All stock updates go through `updateStockAtomically` or the new RPC function
    - No direct `repo.update()` calls modify stock
    - Code review confirms no read-modify-write patterns for stock

## Technical Considerations

### Architecture Layers Impacted

-   **Infrastructure Layer** (`infrastructure/supabase/`):

    -   Create new migration: `007_add_recalculate_stock_function.sql`
    -   Add PostgreSQL RPC function `recalculate_and_update_stock(product_id UUID)`
    -   Function should: calculate stock from activities, update product stock atomically, return new stock value

-   **Ports Layer** (`core/ports/productRepository.ts`):

    -   Add new method: `recalculateStockFromActivities(id: ProductId): Promise<number>`
    -   Document that this method is atomic and recalculates from source of truth

-   **Infrastructure Layer** (`infrastructure/supabase/productRepositorySupabase.ts`):

    -   Implement `recalculateStockFromActivities` using the new RPC function

-   **Usecases Layer** (`core/usecases/product.ts`):

    -   Modify `updateProduct` to reject `stock` in updates
    -   Add validation: if `updates.stock !== undefined`, throw error with clear message
    -   Update JSDoc to document that stock cannot be updated via this method

-   **Usecases Layer** (`core/usecases/activity.ts`):
    -   Replace read-modify-write pattern in `updateActivity` (lines 433-451)
    -   Use `productRepo.recalculateStockFromActivities(productId)` instead
    -   Remove `getById` call and delta calculation logic
    -   Update JSDoc to document atomic stock recalculation

### Database Function Design

```sql
CREATE OR REPLACE FUNCTION recalculate_and_update_stock(
    p_product_id UUID
)
RETURNS NUMERIC
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_calculated_stock NUMERIC;
    v_new_stock NUMERIC;
BEGIN
    -- Calculate stock from all activities for this product
    SELECT COALESCE(SUM(quantity), 0)
    INTO v_calculated_stock
    FROM activities
    WHERE product_id = p_product_id
      AND type IN ('CREATION', 'SALE', 'STOCK_CORRECTION')
      AND quantity != 0;

    -- Atomically update product stock (clamped to 0 minimum)
    UPDATE products
    SET stock = GREATEST(0, v_calculated_stock)
    WHERE id = p_product_id
    RETURNING stock INTO v_new_stock;

    IF v_new_stock IS NULL THEN
        RAISE EXCEPTION 'Product with id % not found', p_product_id;
    END IF;

    RETURN v_new_stock;
END;
$$;
```

### Error Handling

-   `updateProduct`: Throw descriptive error: "Stock cannot be updated directly. Stock is managed automatically through activities. Use activity creation/update to modify stock levels."
-   `recalculateStockFromActivities`: Handle product not found errors and database errors appropriately

## Definition of Done

-   [ ] PostgreSQL RPC function `recalculate_and_update_stock` created and tested
-   [ ] Migration `007_add_recalculate_stock_function.sql` created and documented
-   [ ] `ProductRepository` interface updated with `recalculateStockFromActivities` method
-   [ ] `productRepositorySupabase` implements `recalculateStockFromActivities` using RPC
-   [ ] `updateProduct` rejects `stock` updates with clear error message
-   [ ] `updateActivity` uses `recalculateStockFromActivities` instead of read-modify-write pattern
-   [ ] All existing tests pass
-   [ ] New tests verify:
    -   `updateProduct` rejects stock updates
    -   `updateActivity` handles concurrent updates correctly (no race conditions)
    -   `recalculateStockFromActivities` calculates and updates stock atomically
-   [ ] Code review confirms no read-modify-write patterns for stock remain
-   [ ] JSDoc updated for all modified functions
-   [ ] No linter errors

## Related Components

### Files to Modify

-   `src/infrastructure/supabase/migrations/007_add_recalculate_stock_function.sql` (new)
-   `src/core/ports/productRepository.ts`
-   `src/infrastructure/supabase/productRepositorySupabase.ts`
-   `src/core/usecases/product.ts`
-   `src/core/usecases/activity.ts`

### Files to Test

-   `__tests__/core/usecases/product.test.ts`
-   `__tests__/core/usecases/activity.test.ts`
-   `__tests__/core/ports/productRepository.test.ts` (if exists)
-   `__tests__/infrastructure/supabase/productRepositorySupabase.test.ts` (if exists)

## Dependencies

-   Requires existing `updateStockAtomically` functionality (FBC-29)
-   Requires `activities` table structure
-   Requires `products` table with `stock` column

## Notes

-   This ticket addresses critical data consistency issues identified in code review
-   The race condition in `updateActivity` is particularly important to fix as it can lead to incorrect stock values under concurrent load
-   Preventing direct stock updates in `updateProduct` ensures that stock is always managed through activities, maintaining data integrity
-   The new RPC function provides a single source of truth for stock calculation and update
