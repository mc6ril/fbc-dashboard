---
Generated: 2025-01-27 20:30:00
Ticket Number: 27
Parent Ticket: 26
---

# Add product filtering usecases (Core layer)

-   Type: Feature
-   Priority: Medium
-   Story Points: 2
-   Labels: core, usecases, products, filtering
-   Git Branch: feat/fbc-27-product-filtering-usecases

## Description

Add usecases for filtering products by type, model name, and coloris. These usecases will provide the business logic needed to support cascading product selection in the add activity form.

**Current state:**
-   `listProducts` usecase exists and returns all products
-   No filtering usecases exist
-   Filtering would need to be done in presentation layer

**Business requirement:**
-   Need to filter products by type to populate Product Type dropdown
-   Need to extract unique model names (name field) for a given type
-   Need to extract unique coloris for a given type + model combination
-   Filtering should be done at usecase level to maintain Clean Architecture

## User Story

**As a** developer  
**I want** product filtering logic in usecases  
**So that** filtering is centralized and reusable across the application

## Acceptance Criteria

-   [ ] Add `listProductsByType` usecase in `src/core/usecases/product.ts`
    -   Takes `ProductRepository` and `ProductType` as parameters
    -   Returns `Promise<Product[]>` with products matching the type
    -   Returns empty array if no products match
    -   Throws error if repository retrieval fails
-   [ ] Add `listProductModelsByType` usecase in `src/core/usecases/product.ts`
    -   Takes `ProductRepository` and `ProductType` as parameters
    -   Returns `Promise<string[]>` with unique model names (name field) for the type
    -   Returns empty array if no products match
    -   Throws error if repository retrieval fails
-   [ ] Add `listColorisByTypeAndModel` usecase in `src/core/usecases/product.ts`
    -   Takes `ProductRepository`, `ProductType`, and `name: string` as parameters
    -   Returns `Promise<string[]>` with unique coloris for the type + model combination
    -   Returns empty array if no products match
    -   Throws error if repository retrieval fails
-   [ ] All usecases use existing `repository.list()` method and filter in-memory
-   [ ] All usecases are properly documented with JSDoc
-   [ ] All usecases have proper TypeScript types

## Technical Considerations

**Clean Architecture:**
-   Usecases layer (`core/usecases/`)
-   Uses existing `ProductRepository` port (no changes needed)
-   Filters products in-memory using existing `list()` method
-   Returns domain types only

**Implementation approach:**
-   Use existing `listProducts` usecase internally, or call `repository.list()` directly
-   Filter products in-memory using Array methods (`.filter()`, `.map()`, `.reduce()`)
-   Extract unique values using `Set` or `Array.from(new Set(...))`

**Performance:**
-   In-memory filtering is acceptable for small to medium product catalogs
-   For large catalogs, consider adding repository-level filtering in future tickets

## Definition of Done

-   [ ] All three usecases implemented in `src/core/usecases/product.ts`
-   [ ] Usecases properly typed with TypeScript
-   [ ] Usecases documented with JSDoc
-   [ ] Usecases tested (unit tests in `__tests__/core/usecases/product.test.ts`)
-   [ ] Lint/build passes
-   [ ] No business logic in presentation layer

## Related Components

-   `src/core/usecases/product.ts` - File to update
-   `src/core/ports/productRepository.ts` - Uses existing interface
-   `__tests__/core/usecases/product.test.ts` - Tests to add

## Dependencies

-   None (uses existing ProductRepository)

## Notes

-   This ticket focuses on core business logic only
-   No UI changes in this ticket
-   Filtering is done in-memory for simplicity
-   Can be optimized later with repository-level filtering if needed

