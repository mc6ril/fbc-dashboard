---
alwaysApply: true
---

# Intent

Maintenir une Clean Architecture stricte avec séparation claire des responsabilités entre Domain, Usecases, Infrastructure et Presentation. Aucune logique métier ne doit se trouver dans la UI ou l'infrastructure.

## CRITICAL RULES - ARCHITECTURE NEVER OPTIONAL

### 1. Layer Separation - STRICT ENFORCEMENT

-   **ALWAYS** respecter la séparation des couches : Domain → Usecases → Infrastructure → Presentation
-   **NEVER** mélanger les responsabilités entre couches
-   **ALWAYS** suivre le flux unidirectionnel : UI → Hooks → Usecases → Repositories → Supabase
-   **NEVER** inverser le flux (ex: Infrastructure → Presentation)

### 2. Domain Layer (core/domain) - PURE TYPESCRIPT ONLY

-   **ALWAYS** placer les types/interfaces métiers dans `core/domain/`
-   **ALWAYS** placer les règles métier pures dans `core/domain/` (ex: `isLowStock(product)`)
-   **NEVER** importer Supabase, React, Zustand, React Query, ou Next.js dans le domain
-   **NEVER** mettre de logique dépendante d'infrastructure dans le domain
-   **ALWAYS** garder le domain pur TypeScript sans dépendances externes

### 3. Usecases Layer (core/usecases) - BUSINESS LOGIC ORCHESTRATION

-   **ALWAYS** créer des fonctions pures qui orchestrent la logique métier
-   **ALWAYS** passer les repositories (ports) en paramètre aux usecases
-   **ALWAYS** retourner des données du domaine depuis les usecases
-   **NEVER** importer Supabase directement dans un usecase
-   **NEVER** importer React, Zustand, ou Next.js dans un usecase
-   **ALWAYS** utiliser les ports (interfaces) pour accéder aux données

**Exemple structure obligatoire :**

```typescript
export async function listProducts(repo: ProductRepository) {
    return repo.list();
}
```

### 4. Ports Layer (core/ports) - REPOSITORY CONTRACTS

-   **ALWAYS** définir les interfaces des repositories dans `core/ports/`
-   **ALWAYS** nommer les ports avec le suffixe "Repository" (ex: `ProductRepository`)
-   **NEVER** implémenter la logique dans les ports, seulement les contrats
-   **ALWAYS** utiliser les ports comme types dans les usecases

### 5. Infrastructure Layer (infrastructure/) - CONCRETE IMPLEMENTATIONS

-   **ALWAYS** implémenter les ports dans `infrastructure/supabase/`
-   **ALWAYS** nommer les implémentations avec le suffixe "Supabase" (ex: `productRepositorySupabase`)
-   **ALWAYS** implémenter les interfaces définies dans `core/ports/`
-   **NEVER** importer la UI ou Zustand dans l'infrastructure
-   **ALWAYS** utiliser Supabase, Fetch, ou autres libs externes uniquement dans l'infrastructure

**Exemple structure obligatoire :**

```typescript
export const productRepositorySupabase: ProductRepository = {
    list: async () => {
        // ...supabase.from("products")...
    },
};
```

### 6. Presentation Layer - UI ONLY, NO BUSINESS LOGIC

#### 6.1. Components (presentation/components)

-   **ALWAYS** créer des composants UI purs sans logique métier
-   **NEVER** appeler Supabase directement depuis un composant
-   **NEVER** mettre de logique métier dans les composants
-   **ALWAYS** recevoir les données déjà prêtes via props
-   **ALWAYS** utiliser les hooks React Query pour récupérer les données
-   **ALWAYS** placer les composants réutilisables (Button, Input, Card, etc.) dans `presentation/components/ui/`
-   **NEVER** créer de composants réutilisables ailleurs que dans `presentation/components/ui/`

#### 6.2. Hooks (presentation/hooks)

-   **ALWAYS** créer des hooks React Query dans `presentation/hooks/`
-   **ALWAYS** appeler les usecases depuis les hooks, pas directement l'infrastructure
-   **ALWAYS** fournir `data`, `isLoading`, `error` depuis les hooks
-   **NEVER** mettre de logique métier dans les hooks, seulement orchestration
-   **ALWAYS** utiliser la structure suivante :

```typescript
export function useProducts() {
    return useQuery({
        queryKey: ["products"],
        queryFn: () => listProducts(productRepositorySupabase),
    });
}
```

#### 6.3. Stores Zustand (presentation/stores)

-   **ALWAYS** stocker uniquement le state UI (filtres, modales, catégories, drawer)
-   **NEVER** mettre de logique métier dans les stores Zustand
-   **NEVER** appeler Supabase ou usecases depuis les stores
-   **ALWAYS** garder les stores pour l'état UI uniquement

#### 6.4. Providers (presentation/providers)

-   **ALWAYS** créer les providers globaux dans `presentation/providers/`
-   **ALWAYS** inclure ReactQueryProvider pour React Query
-   **NEVER** mettre de logique métier dans les providers

### 7. Shared Layer (shared/) - SHARED CODE

-   **ALWAYS** placer le code partagé entre les couches dans `shared/`
-   **ALWAYS** placer les utilitaires d'accessibilité dans `shared/a11y/`
-   **ALWAYS** placer les constantes d'accessibilité dans `shared/a11y/`
-   **NEVER** mettre de logique métier dans shared
-   **ALWAYS** garder shared pour les utilitaires et constantes transversaux
-   **ALWAYS** permettre l'import de shared depuis toutes les couches (domain, usecases, infrastructure, presentation)

### 8. File Organization - MANDATORY STRUCTURE

-   **ALWAYS** créer les fichiers dans les bons dossiers selon leur rôle :
    -   Types métiers → `core/domain/`
    -   Usecases → `core/usecases/`
    -   Interfaces repositories → `core/ports/`
    -   Implémentations Supabase → `infrastructure/supabase/`
    -   Composants UI spécifiques → `presentation/components/`
    -   **Composants réutilisables** (Button, Input, Card, etc.) → `presentation/components/ui/`
    -   Hooks React Query → `presentation/hooks/`
    -   Stores Zustand → `presentation/stores/`
    -   Providers → `presentation/providers/`
    -   **Accessibilité** (utilitaires, constantes) → `shared/a11y/`

### 9. Import Rules - STRICT DEPENDENCY DIRECTION

-   **ALWAYS** respecter la direction des imports :
    -   Domain : aucun import externe (sauf `shared/` si nécessaire)
    -   Usecases : importe Domain et Ports uniquement (sauf `shared/` si nécessaire)
    -   Infrastructure : importe Domain et Ports uniquement (sauf `shared/` si nécessaire)
    -   Presentation : importe Domain, Usecases, et Infrastructure uniquement (sauf `shared/` si nécessaire)
    -   Shared : peut être importé par toutes les couches
-   **NEVER** faire d'imports transversaux interdits (ex: infrastructure → presentation)
-   **NEVER** importer Supabase dans `/core/`
-   **NEVER** importer React/Next.js dans `/core/`
-   **ALWAYS** utiliser `shared/a11y/` pour tous les utilitaires et constantes d'accessibilité

## ARCHITECTURE VIOLATIONS - AUTO-STOP CONDITIONS

### 10. Critical Violations - ALWAYS STOP

1. **Import Supabase dans core/** → STOP et utiliser un port à la place
2. **Logique métier dans un composant** → STOP et déplacer vers un usecase
3. **Appel Supabase depuis la UI** → STOP et utiliser un hook React Query
4. **Logique métier dans Zustand** → STOP et déplacer vers un usecase
5. **Hook appelant directement l'infrastructure** → STOP et passer par un usecase
6. **Import React/Next.js dans core/** → STOP et garder le core pur TypeScript
7. **Import UI dans infrastructure** → STOP et respecter la séparation
8. **Composant réutilisable hors de `presentation/components/ui/`** → STOP et déplacer dans `presentation/components/ui/`

## ARCHITECTURE COMPLIANCE - MANDATORY VERIFICATION

### 11. Code Generation Checklist

Before EVERY code generation:

✅ **Layer Separation**

-   Fichier créé dans le bon dossier selon son rôle?
-   Aucun import inter-couches interdit?
-   Flux respecté (UI → Hook → Usecase → Repository)?

✅ **Domain Layer**

-   Types métiers dans core/domain?
-   Aucun import externe dans le domain?
-   Règles métier pures sans dépendances?

✅ **Usecases Layer**

-   Usecase prend un repository en paramètre?
-   Aucun import Supabase/React dans le usecase?
-   Retourne des données du domaine?

✅ **Infrastructure Layer**

-   Implémente un port défini dans core/ports?
-   Aucun import UI/Zustand?
-   Utilise Supabase uniquement ici?

✅ **Presentation Layer**

-   Composant sans logique métier?
-   Composants réutilisables dans `presentation/components/ui/`?
-   Hook appelle un usecase, pas directement l'infrastructure?
-   Store Zustand pour UI state uniquement?

## DATA FLOW REFERENCE - ALWAYS FOLLOW

```
UI (Page Next)
    ↓ appelle
Hook React Query (useProducts)
    ↓ appelle
Usecase (listProducts)
    ↓ appelle
Repository (productRepositorySupabase)
    ↓ appelle
Supabase (infrastructure)
```

**Toujours dans ce sens. Jamais l'inverse.**

This ensures strict Clean Architecture compliance and maintainable, testable code with clear separation of concerns.
