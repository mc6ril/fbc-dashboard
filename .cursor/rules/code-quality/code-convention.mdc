---
alwaysApply: true
name: "Code Style & Conventions"
description: "Consistent code style, naming conventions, TypeScript patterns, and code quality standards across the codebase."
globs: ["src/**/*.{ts,tsx,scss}"]
priority: medium
---

# Intent

Maintain strict and consistent code conventions for style, naming, TypeScript patterns, and code quality, independent of architecture.

## CRITICAL RULES - CODE CONVENTIONS NEVER OPTIONAL

### 1. TypeScript Style - STRICT ENFORCEMENT

-   **ALWAYS** use TypeScript strict at all times
-   **NEVER** use `any` - always type explicitly
-   **ALWAYS** prefer explicit types
-   **ALWAYS** write short, readable, and pure functions
-   **NEVER** create unnecessarily complex logic

### 2. Control statements must use braces

-   **ALWAYS** wrap control statements with braces, even for single statements.

### 3. SCSS / Styling - MANDATORY STRUCTURE

#### SCSS Structure

-   **ALWAYS** place global SCSS in `styles/global.scss`
-   **ALWAYS** place variables in `styles/variables/*`
-   **ALWAYS** place UI components in `styles/components/*`

#### SCSS Variables - MANDATORY USAGE

-   **ALWAYS** use only variables from `styles/variables/*` for all styles
-   **NEVER** create styles with hardcoded values (colors, spacing, sizes, etc.)
-   **ALWAYS** if a variable doesn't exist in `styles/variables/*`, add it to the dedicated section of the appropriate file
-   **NEVER** use direct values (e.g., `#fff`, `16px`, `1rem`) without using a variable

#### SCSS Naming Rules

-   **ALWAYS** name classes in kebab-case: `.product-card`
-   **ALWAYS** use `__` for sub-elements: `.product-card__title`
-   **ALWAYS** use `--` for variations: `.button--primary`
-   **NEVER** use inline CSS in React components
-   **NEVER** use `!important`

### 4. React / Next.js Components - STRICT PATTERNS

#### Component Format

-   **ALWAYS** use arrow function with export default
-   **NEVER** use ES6 classes
-   **NEVER** use `export function`
-   **ALWAYS** name components in PascalCase
-   **ALWAYS** use `const ComponentName = () => {}`
-   **ALWAYS** use `export default ComponentName` at the end

**Mandatory structure:**

```typescript
const ComponentName = () => {
    // ...
};

export default ComponentName;
```

#### Props

-   **ALWAYS** define props type above the component
-   **ALWAYS** use `type` for props (never `interface`)

**Mandatory structure:**

```typescript
type Props = {
    products: Product[];
};

const ProductList = ({ products }: Props) => {
    // ...
};

export default ProductList;
```

#### JSX

-   **NEVER** make network calls in JSX
-   **NEVER** put business logic in JSX
-   **NEVER** do heavy calculations in JSX
-   **ALWAYS** use `&&` or ternaries for conditions
-   **NEVER** use `if` in JSX

#### Files

-   **ALWAYS** use `.tsx` extension for components
-   **ALWAYS** respect: one file = one main component

### 5. Zustand Stores - UI STATE ONLY

-   **ALWAYS** create one store per UI state domain (filters, modals, selection, theme, etc.)
-   **NEVER** put side effects in stores
-   **NEVER** create direct link with Supabase, React Query, or business logic
-   **ALWAYS** name stores: `useXxxStore.ts`

**Mandatory structure:**

```typescript
export const useFilterStore = create<FilterState>((set) => ({
    search: "",
    setSearch: (v) => set({ search: v }),
}));
```

### 6. React Query Hooks - DATA FETCHING PATTERNS

-   **ALWAYS** create one hook per resource: `useProducts`, `useStockMovements`, etc.
-   **ALWAYS** use explicit and stable queryKey: `queryKey: ["products"]`
-   **NEVER** make direct Supabase call - only execute a usecase
-   **ALWAYS** return: `data`, `isLoading`, `error`

**Mandatory structure:**

```typescript
export function useProducts() {
    return useQuery({
        queryKey: ["products"],
        queryFn: () => listProducts(productRepositorySupabase),
    });
}
```

### 7. Types & Naming - STRICT CONVENTIONS

#### Types

-   **ALWAYS** place business types in `core/domain` and use them everywhere via imports
-   **NEVER** use prefixes (no `IProduct`, `IUser`)
-   **ALWAYS** prefer: `Product`, `StockMovement`

#### Interface vs Type vs Enum

-   **ALWAYS** use `interface` **ONLY** for classes
-   **ALWAYS** use `type` for everything else (props, objects, unions, intersections, etc.)
-   **ALWAYS** use `enum` for enumerated constants

**Mandatory examples:**

```typescript
// ✅ Interface only for classes
interface IRepository {
    list(): Promise<Product[]>;
}

class ProductRepository implements IRepository {
    // ...
}

// ✅ Type for props, objects, etc.
type Product = {
    id: string;
    name: string;
};

type Props = {
    products: Product[];
};

// ✅ Enum for constants
enum ProductStatus {
    ACTIVE = "active",
    INACTIVE = "inactive",
}
```

#### Naming

-   **ALWAYS** use camelCase for variables and functions
-   **ALWAYS** use PascalCase for types / components

#### File Naming

-   `ProductTable.tsx` → Component
-   `useProducts.ts` → React Query hook
-   `useProductFilterStore.ts` → Zustand store
-   `productRepositorySupabase.ts` → Infrastructure repository

### 8. Tests - MANDATORY COVERAGE

-   **ALWAYS** write unit tests for `domain` and `usecases`
-   **NEVER** make UI tests mandatory for page components
-   **ALWAYS** write mandatory tests for reusable components in `presentation/components/ui`

### 9. Imports - ORDER AND CLEANLINESS

#### Mandatory Order

1. External libraries (React, Zustand, React Query…)
2. Types / domain
3. Usecases
4. Infrastructure
5. Presentation (components, hooks, stores)
6. Styles or SCSS modules
7. Relative imports

#### Rules

-   **ALWAYS** remove unused imports

### 10. Code Quality - BEST PRACTICES

-   **ALWAYS** name functions according to what they actually do
-   **ALWAYS** prefer pure functions
-   **ALWAYS** split components that are too long
-   **ALWAYS** use `async/await` rather than `.then()`
-   **ALWAYS** type return values of public functions
-   **NEVER** ignore a network error (always at least a `throw`)

## CODE CONVENTION VIOLATIONS - AUTO-STOP CONDITIONS

### 11. Critical Violations - ALWAYS STOP

1. **Use of `any`** → STOP and type explicitly
2. **Inline CSS in component** → STOP and use SCSS
3. **Hardcoded value in SCSS** → STOP and create/use a variable in `styles/variables/*`
4. **`export function` for component** → STOP and use `const ComponentName = () => {}`
5. **`interface` for props** → STOP and use `type`
6. **`if` in JSX** → STOP and use `&&` or ternary
7. **Business logic in JSX** → STOP and move to a hook or usecase
8. **Network call in component** → STOP and use a React Query hook
9. **Side effect in Zustand store** → STOP and move the logic
10. **Unused imports** → STOP and remove
11. **Function without return type** → STOP and type explicitly

## CODE CONVENTION COMPLIANCE - MANDATORY VERIFICATION

### 12. Code Generation Checklist

Before EVERY code generation:

✅ **TypeScript**

-   TypeScript strict enabled?
-   No `any` used?
-   Explicit types everywhere?

✅ **Components**

-   Arrow function format with export default?
-   Props typed with `type`?
-   No business logic in JSX?

✅ **Styling**

-   SCSS in correct directories?
-   All values use variables from `styles/variables/*`?
-   Missing variables added in `styles/variables/*`?
-   Classes in kebab-case?
-   No inline CSS?
-   No hardcoded values?

✅ **State Management**

-   Zustand store for UI state only?
-   React Query hook calls a usecase?
-   No side effects in stores?

✅ **Types**

-   `interface` only for classes?
-   `type` for props and objects?
-   `enum` for constants?

✅ **Imports**

-   Order respected?
-   Unused imports removed?

✅ **Code Quality**

-   Pure functions preferred?
-   Explicit return types?
-   Appropriate error handling?

This ensures consistent, maintainable, and high-quality code across the entire codebase.
